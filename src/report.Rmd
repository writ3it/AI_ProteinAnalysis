---
title: "Basic analysis of ligands"
author: "writ3it"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    highlight: kate
    number_sections: yes
    theme: united
    toc: true
    toc_float: true
params:
  source_url: "https://zenodo.org/record/1040778/files/all_summary.7z"
  zipped: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
working_dir <-getwd()
```

# Summary

- how to process NAs
- empty attributes (zeros)
- correlation pearson

# Analysis

## Used R libraries 
- psych - for "describe" function
- ggplot2 - for visualisations 
- dplyr - for human-friendly data processing 
- friendlyeval - for dynamic column selection while dlypr processing
- reshape2 - for very usefull melt function (R implementation is very slow!)
- shiny - for dynamic correlation chart
- DT - for dynamic tables
- archive - for 7z extraction
- grid,gridExtra - for plot grid
```{r libs, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
if (!require("psych")){ install.packages('psych') }
library(psych)
if (!require("ggplot2")){ install.packages('ggplot2') }
library(ggplot2)
if (!require("dplyr")){ install.packages('dplyr') }
library(dplyr)
if (!require("DT")){ install.packages('DT') }
library(DT)
if (!require("DT")){ 
devtools::install_github("milesmcbain/friendlyeval")
}
library(friendlyeval)
library(reshape2)
# needs libarchive-dev
if (!require("DT")){ 
devtools::install_github("jimhester/archive")
}
library(archive)
library(plotly)
library(grid)
if (!require("gridExtra")){ install.packages("gridExtra") }
library(gridExtra)
```

## Initialization code
```{r init}
set.seed(23) # for random functions
prettyTable <- function(table_df, round_columns=numeric(), round_digits=2) {
    DT::datatable(table_df, style="bootstrap", filter = "top", rownames = FALSE, extensions = "Buttons", options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))) %>%
    formatRound(round_columns, round_digits)
} # same look of tables
```

## Data loading

### Downloading dataset
```{r loading}
tempFilePath <- paste(working_dir,"/../data/temp.7z",sep='')
dataFilePath <- paste(working_dir,"/../data/all_summary.csv",sep='')
if (!file.exists(dataFilePath)){
  message("Downloading data from: ",params$source_url);
  download.file(params$source_url,tempFilePath)
  archive_extract(tempFilePath,"./data");
  if (!file.exists(dataFilePath)){
    stop("Data file not found");
  }
} else {
  message("Data was downloaded previously. Be careful!")
}
```



### Reading sample data
```{r sample_data}
sampleRowsNo <- 1000
sample <- read.table(dataFilePath,header = TRUE, nrows = sampleRowsNo, sep = ";");
```
```{r init_data,echo=FALSE}
data <- sample
```

### Dataset attributes lists 

```{r attribs}
noTopClasses <- 50
#target class for classification
attrib.target_class <- "res_name"
#all attributes
attrib.all <- colnames(data)
#"local" attributes
attrib.local <- attrib.all[ grepl("local_", attrib.all)]
# dict_atom attribs
attrib.dict <- attrib.all[grepl("dict_atom_", attrib.all)]
# parts 
attrib.part <- attrib.all[grepl("part_",attrib.all)]
# skeleton
attrib.skeleton <- attrib.all[grepl("skeleton_",attrib.all)]
# resolution
attrib.res <- "resolution"
# params
attrib.params <- c("fo_col","fc_col","weight_col","grid_space","solvent_radius","solvent_opening_radius")
#uknown columns
attrib.unknown <- c("blob_coverage","blob_volume_coverage_second","resolution_max_limit","FoFc_square_std","res_coverage","res_volume_coverage","FoFc_mean","FoFc_min","blob_volume_coverage","res_volume_coverage_second","FoFc_std","FoFc_max","resolution")
# illegal attribs for classifications
attrib.illegal <- c(c(
  "title",
  "pdb_code",
  "res_name",
  "res_id",
  "chain_id",
  "local_",
  "weight_col", #is na!
  "skeleton_data"
),
#attrib.local, #local are illegal,
#attrib.dict, #dicts are illegal,
attrib.unknown,
attrib.params
)

attrib.legal<-setdiff(attrib.all, c(attrib.illegal,attrib.local, attrib.dict))

attrib.part.shape <- attrib.legal[grepl("_shape_",attrib.legal)]
attrib.part.density <- attrib.legal[grepl("_density_",attrib.legal)]
```
## Data cleansing

### Remove unnecesary ligands (project requirement)
```{r cleansing_1}
excluded_names <- c("UNK", "UNX", "UNL", "DUM", "N", "BLOB", "ALA", "ARG", "ASN", "ASP", "CYS", "GLN", "GLU", "GLY", "HIS", "ILE", "LEU", "LYS", "MET", "MSE", "PHE", "PRO", "SEC", "SER", "THR", "TRP", "TYR", "VAL", "DA", "DG", "DT", "DC", "DU", "A", "G", "T", "C", "U", "HOH", "H20", "WAT");
data.raw <- data %>%
  filter(!res_name %in% excluded_names) %>%
  filter(!is.na(res_name))
  
```

### Filling data gaps
```{r cleansing_2, message=FALSE}
replacements <<- data.raw %>% 
  select(c(attrib.legal,attrib.target_class),-c("skeleton_data")) %>% 
  na.omit %>%
  group_by(res_name) %>% 
  summarize_all(funs(mean))

ids <- data.raw[,attrib.target_class]

#?mutate
for (col in colnames(replacements)){
  column<-data.raw[,col]
  bad <- is.na(column)
  bad_ids = ids[bad]
  if (sum(bad)==0){
    next
  }
  bad_ids <- data.frame(bad_ids)
  colnames(bad_ids)<-c(attrib.target_class)
  vals <- data.frame(bad_ids) %>% left_join(replacements) %>% select(!!treat_string_as_col(col))
  new_vals <- unlist(vals, use.names = FALSE)
  data.raw[bad,col] <- new_vals
}

data.withoutGaps <- data.raw %>% replace(is.na(.),0)
```

## Dataset description
### Simple statistics
```{r desc, show, echo=FALSE}
cat("Number of rows: ",nrow(data.withoutGaps))
cat("Number of attributes: ",ncol(data.withoutGaps))
cat("Number of legal attributes: ",length(data.withoutGaps))
```
### Attributes
```{r desc_attribs, echo=FALSE}
describe(data.withoutGaps)
```

### Find empty numeric attributes
```{r removeEmptyColumns}
stats <- data.withoutGaps %>% select(attrib.legal) %>% summarise_all(funs(min,max))
attrib.empty <- c()
for ( col in attrib.legal){
  max <- stats[1,paste(col,"_max",sep="")]
  min <- stats[1,paste(col,"_min",sep="")]
  diff <- max - min
  if (diff == 0){
    attrib.empty <- c(attrib.empty,col)
  }
}
```


## Processing

### Choose top 50 ligands, number of examples per class

```{r find_top_50}
top50 <- data.withoutGaps %>% group_by(!!treat_string_as_col(attrib.target_class)) %>% summarize(numberOfExamples = n()) %>% arrange(desc(numberOfExamples)) %>% head(noTopClasses) 
top50
top50 <- top50 %>% select(c(attrib.target_class))
```
```{r limit_data}
.topClasses<-unlist(top50[,attrib.target_class],use.names = FALSE)
data.top50 <- data.withoutGaps %>% filter( !!treat_string_as_col(attrib.target_class) %in% .topClasses )
data.withoutEmpty <- data.top50 %>% select(-attrib.empty)
```

### Correlation

```{r correlation}

data.legal <- data.withoutEmpty %>% select(setdiff(attrib.legal,attrib.empty)) 
correlation <- cor(data.legal)
```
```{r presentation}
melted <- melt(correlation)
df.cor.mel <- data.frame(melted)  %>% mutate(value = abs(value)) %>% arrange(desc(value))

p<-ggplot(
      df.cor.mel
      ,aes(x=Var1,y=Var2, fill=value)) +
      geom_tile() +
      scale_fill_gradient(low = "white", high = "brown") +
      xlab("parameters") +
      ylab("parameters") + 
      theme(axis.text.x = element_text(angle = -90, hjust = 1))

ggplotly(p,height=700, width=700)



```

### Distribution of atoms nad electrons
```{r distr, echo=FALSE,message=FALSE}
dist <- data.top50 %>% select(c(attrib.target_class, "local_res_atom_non_h_count","local_res_atom_non_h_electron_sum"))
mdist <- melt(dist)

format_plot <- function(p,color, title){
   p+geom_histogram(alpha=0.5, position="identity", aes(y = ..density..), color="black", fill=color) + 
    scale_y_sqrt() +
    ggtitle(title) + 
    xlab("value") + 
    ylab("sqrt(cardinality)") 
}


p<- ggplot(dist,aes(x=dist$local_res_atom_non_h_count))
p1 <- format_plot(p,"yellow","Distribution of no_atoms")
p<- ggplot(dist,aes(x=dist$local_res_atom_non_h_electron_sum))
p2 <- format_plot(p,"blue","Distribution of no_electrons")
grid.arrange(p1,p2)
```

### Analyze part_01 parameters

```{r part_01, echo=FALSE,message=FALSE}
attrib.part_01 <- attrib.part[grepl("part_01",attrib.part)]
data <- data.withoutEmpty %>% select(c(attrib.target_class,attrib.part_01))
parts <- melt(data)

unames <- unlist(unique(parts[,attrib.target_class]))
uvars <- unlist(unique(parts[,'variable']))

button.names <- lapply(unames, function(name){
  list(
    method="restyle",
    args=list("transforms[0].value",name),
    label= name
  )
})

button.vars <- lapply(uvars, function(v){
  list(
    method="restyle",
    args=list("transforms[1].value",v),
    label= v
  )
})

       
parts %>% plot_ly(
                  x=parts$value,
                  type="histogram",
                  transforms=list(
                    list(
                      type="filter",
                      target= ~res_name,
                      orientation = '=',
                      value = unames[1]
                    ),
                     list(
                      type="filter",
                      target= ~variable,
                      orientation = '=',
                      value = uvars[1]
                    )
                  )) %>%
 
  layout(
    title="Distribution of Values",
    updatemenus=list(
      list(
        type='dropdown',
        y=0.8,
        x=-0.1,
        buttons = button.names
      ),
      list(
        type='dropdown',
        y=0.6,
        x=-0.1,
        buttons = button.vars
      )
    ),
   yaxis = list(
      title = "Cardinality"
    ),
    annotations=list(
      list(
        x=-0.27,
        y=0.85,
        xref='paper',
        yref='paper',
        text="res_name",
        showarrow=FALSE
      ),
      list(
        x=-0.27,
        y=0.65,
        xref='paper',
        yref='paper',
        text="parameter",
        showarrow=FALSE
      )
    )
  )


```
### The 10 most incompatible classes
I understand by incmpatible sum(abs(local*,dict*))
```{r incomp, echo=FALSE}
f <- data.withoutEmpty %>% 
  select(!!treat_string_as_col(attrib.target_class),
         local_res_atom_non_h_count,
         dict_atom_non_h_count,
         dict_atom_non_h_electron_sum,
         local_res_atom_non_h_electron_sum) %>%
  arrange(res_name)

f<-f %>%
  group_by(!!treat_string_as_col(attrib.target_class)) %>%
  summarize( 
    atoms = sum(abs(local_res_atom_non_h_count-dict_atom_non_h_count)),
    electrons = sum(abs(local_res_atom_non_h_electron_sum-dict_atom_non_h_electron_sum))
    )

df.atoms <- f%>% select(!!treat_string_as_col(attrib.target_class),atoms) %>% arrange(desc(atoms)) %>% head(10)
df.electrons <- f%>% select(!!treat_string_as_col(attrib.target_class),electrons) %>% arrange(desc(electrons)) %>% head(10)
prettyTable(df.atoms)
prettyTable(df.electrons)
  
```


